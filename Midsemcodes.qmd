## Class 10
## Complex surveys

1. Estimated variance of weighted mean
```{r}
# Function to estimate variance of a weighted mean
var_weighted_mean <- function(u, w) {
  # u: vector of values
  # w: vector of weights
  
  # Calculate weighted mean (r)
  r <- sum(u) / sum(w)
  
  # Calculate variance components
  var_u <- var(u) * (length(u) - 1) / length(u)  # Population variance
  var_w <- var(w) * (length(w) - 1) / length(w)  # Population variance
  
  # Calculate covariance between u and w
  cov_uw <- cov(u, w) * (length(u) - 1) / length(u)  # Population covariance
  
  # Calculate total weight
  total_w <- sum(w)
  
  # Apply the formula: var(yw) ≈ (1/w²)[var(u) + r²var(w) - 2*r*cov(u,w)]
  variance <- (1 / (total_w^2)) * (var_u + (r^2 * var_w) - (2 * r * cov_uw))
  
  return(variance)
}

# Example usage
u <- c(10, 15, 20, 25, 30)  # Example values
w <- c(1, 2, 1, 3, 2)       # Example weights

result <- var_weighted_mean(u, w)
print(paste("Estimated variance of weighted mean:", result))
```

2. Effective Sample Size with Design Effect

```{r}
# Function to calculate effective sample size
calculate_n_ess <- function(weights) {
  # weights: vector of sampling weights
  
  # Calculate squared sum of weights
  sum_weights_squared <- sum(weights)^2
  
  # Calculate sum of squared weights
  sum_squared_weights <- sum(weights^2)
  
  # Calculate design effect (1 + L)
  deff <- sum_weights_squared / sum_squared_weights
  
  # Calculate effective sample size
  n_nominal <- length(weights)
  n_ess <- n_nominal / deff
  
  return(list(
    nominal_sample_size = n_nominal,
    design_effect = deff,
    effective_sample_size = n_ess
  ))
}

# Example usage
weights <- c(2.5, 1.8, 3.2, 1.0, 2.1, 1.5, 2.0, 3.0, 1.7, 2.2)
result <- calculate_n_ess(weights)
print(paste("Nominal sample size:", result$nominal_sample_size))
print(paste("Design effect:", result$design_effect))
print(paste("Effective sample size:", result$effective_sample_size))
```

3. SRS Variance with FPC for Binary Outcome

```{r}
# Function to calculate SRS variance with finite population correction for binary outcome
srs_var_binary <- function(p, n, N = Inf) {
  # p: proportion (binary outcome)
  # n: sample size
  # N: population size (default: Inf, meaning no FPC)
  
  # Calculate finite population correction
  fpc <- (N - n) / (N - 1)
  if(is.infinite(N)) fpc <- 1
  
  # Calculate variance
  var <- p * (1 - p) / (n - 1) * fpc
  
  return(var)
}

# Example usage
p_est <- 0.3    # Estimated proportion
n <- 100        # Sample size
N <- 1000       # Population size

var_with_fpc <- srs_var_binary(p_est, n, N)
var_without_fpc <- srs_var_binary(p_est, n)

print(paste("Variance with FPC:", var_with_fpc))
print(paste("Variance without FPC:", var_without_fpc))
```

4. Degrees of Freedom for Complex Surveys

```{r}
# Function to calculate degrees of freedom for complex surveys
complex_survey_df <- function(n_clusters, n_strata) {
  # n_clusters: number of primary sampling units (PSUs)
  # n_strata: number of strata
  
  # Calculate degrees of freedom: n - H
  df <- n_clusters - n_strata
  
  return(df)
}

# Example usage
n_clusters <- 50  # Number of PSUs
n_strata <- 10    # Number of strata

df <- complex_survey_df(n_clusters, n_strata)
print(paste("Degrees of freedom:", df))
```

4. Degrees of Freedom for Different Sampling Designs

```{r}
# Function to calculate degrees of freedom for various sampling designs
calculate_df <- function(design_type, M = NULL, n = NULL, H = 1) {
  # design_type: "cluster", "stratified_element", or "srs"
  # M: number of sampled elements
  # n: number of clusters
  # H: number of strata (default: 1)
  
  if (design_type == "cluster") {
    # Cluster sample, no stratification
    df <- n - 1
  } else if (design_type == "stratified_element") {
    # Stratified element sample, no cluster sampling
    df <- M - H
  } else if (design_type == "srs") {
    # Simple random sample
    df <- M - 1
  } else {
    stop("Invalid design type. Use 'cluster', 'stratified_element', or 'srs'")
  }
  
  return(df)
}

# Example usage
# Cluster sample with 30 clusters
df_cluster <- calculate_df("cluster", n = 30)
print(paste("DF for cluster sample:", df_cluster))

# Stratified element sample with 200 elements and 5 strata
df_strat <- calculate_df("stratified_element", M = 200, H = 5)
print(paste("DF for stratified element sample:", df_strat))

# Simple random sample with 100 elements
df_srs <- calculate_df("srs", M = 100)
print(paste("DF for simple random sample:", df_srs))
```


## Class 9

## Sampling with unequal probabilities

1. Variance Estimation for Cluster Designs
```{r}
# Function to calculate inclusion probabilities
calculate_inclusion_probs <- function(selection_probs) {
  # selection_probs: probability of selection on first draw (psi_i)
  # This is a simplified approach - actual calculation depends on the sampling design
  n <- length(selection_probs)
  pi_i <- 1 - (1 - selection_probs)^n
  return(pi_i)
}

# Example usage
selection_probs <- c(0.1, 0.15, 0.2, 0.25, 0.3)
inclusion_probs <- calculate_inclusion_probs(selection_probs)
print("Inclusion probabilities:")
print(inclusion_probs)
```

2. One-stage Sampling with Replacement

```{r}
# Function for one-stage sampling with replacement
one_stage_wr <- function(t_values, psi_values, n) {
  # t_values: cluster totals
  # psi_values: probabilities of selection on first draw
  # n: sample size
  
  # Calculate u_i = t_i/psi_i
  u_values <- t_values / psi_values
  
  # Estimate population total
  t_hat_psi <- mean(u_values)
  
  # Calculate variance estimator
  var_t_hat <- var(u_values) / n
  
  # Calculate weights
  weights <- 1 / (n * psi_values)
  
  # Alternative calculation of total
  t_hat_alt <- sum(weights * t_values)
  
  return(list(
    u_values = u_values,
    t_hat_psi = t_hat_psi,
    variance = var_t_hat,
    weights = weights,
    t_hat_weighted = t_hat_alt
  ))
}

# Example usage
t_values <- c(100, 150, 200, 250, 300)  # Cluster totals
psi_values <- c(0.1, 0.15, 0.2, 0.25, 0.3)  # Selection probabilities
n <- 3  # Sample size

result <- one_stage_wr(t_values, psi_values, n)
print(paste("Estimated population total:", result$t_hat_psi))
print(paste("Variance of estimated total:", result$variance))
print("Sampling weights:")
print(result$weights)
```

3. Two-stage Sampling with Replacement

```{r}
# Function for two-stage sampling with replacement
two_stage_wr <- function(t_estimates, psi_values, n, Q_i) {
  # t_estimates: list of vectors, each vector contains estimated totals for a PSU
  # psi_values: probabilities of selection for PSUs
  # n: number of PSU selections
  # Q_i: vector showing how many times each PSU was selected
  
  # Calculate the estimator for the population total
  sum_numerator <- 0
  for (i in 1:length(psi_values)) {
    if (Q_i[i] > 0) {
      # Sum all estimates for PSU i
      for (j in 1:Q_i[i]) {
        sum_numerator <- sum_numerator + t_estimates[[i]][j] / psi_values[i]
      }
    }
  }
  t_hat_psi <- sum_numerator / n
  
  # Calculate the variance estimator
  squared_diff_sum <- 0
  for (i in 1:length(psi_values)) {
    if (Q_i[i] > 0) {
      for (j in 1:Q_i[i]) {
        squared_diff <- (t_estimates[[i]][j] / psi_values[i] - t_hat_psi)^2
        squared_diff_sum <- squared_diff_sum + squared_diff
      }
    }
  }
  var_t_hat <- squared_diff_sum / (n * (n - 1))
  
  # Calculate weights for SSUs
  weights <- list()
  for (i in 1:length(psi_values)) {
    if (Q_i[i] > 0) {
      M_i <- length(t_estimates[[i]])  # Number of elements in PSU i
      m_i <- Q_i[i]  # Number of samples from PSU i
      weights[[i]] <- rep(1 / (n * psi_values[i] * (m_i / M_i)), m_i)
    } else {
      weights[[i]] <- numeric(0)
    }
  }
  
  return(list(
    t_hat_psi = t_hat_psi,
    variance = var_t_hat,
    weights = weights
  ))
}

# Example usage
# Suppose we have 3 PSUs, with different numbers of estimated totals
t_estimates <- list(
  c(100, 110),  # Estimated totals for PSU 1 (selected twice)
  c(150),       # Estimated totals for PSU 2 (selected once)
  c()           # PSU 3 not selected
)
psi_values <- c(0.4, 0.3, 0.3)  # Selection probabilities for PSUs
n <- 3  # Total number of PSU selections
Q_i <- c(2, 1, 0)  # Number of times each PSU was selected

result <- two_stage_wr(t_estimates, psi_values, n, Q_i)
print(paste("Estimated population total:", result$t_hat_psi))
print(paste("Variance of estimated total:", result$variance))
print("Weights for each PSU's samples:")
print(result$weights)
```

4. Horvitz-Thompson Estimator

```{r}
# Function for Horvitz-Thompson estimator
horvitz_thompson <- function(t_values, pi_i) {
  # t_values: values for sampled units
  # pi_i: inclusion probabilities for sampled units
  
  # Calculate HT estimator
  t_hat_ht <- sum(t_values / pi_i)
  
  return(t_hat_ht)
}

# Example usage
t_values <- c(100, 150, 200)  # Values for sampled units
pi_i <- c(0.3, 0.4, 0.5)     # Inclusion probabilities

t_hat <- horvitz_thompson(t_values, pi_i)
print(paste("Horvitz-Thompson estimate of population total:", t_hat))
```

5. Variance Estimators for One-stage Sampling without Replacement

```{r}
# Function for variance estimation in one-stage sampling without replacement
variance_one_stage_wor <- function(t_values, pi_i, pi_ik = NULL, method = "WR") {
  # t_values: values for sampled units
  # pi_i: inclusion probabilities for sampled units
  # pi_ik: joint inclusion probabilities (matrix)
  # method: "HT" (Horvitz-Thompson), "SYG" (Sen-Yates-Grundy), or "WR" (with-replacement approximation)
  
  n <- length(t_values)
  t_hat_ht <- sum(t_values / pi_i)
  
  if (method == "HT" && !is.null(pi_ik)) {
    # Horvitz-Thompson variance estimator
    var_hat <- 0
    for (i in 1:n) {
      var_hat <- var_hat + (1 - pi_i[i]) * (t_values[i] / pi_i[i])^2
      for (k in 1:n) {
        if (k != i) {
          var_hat <- var_hat + (pi_ik[i, k] - pi_i[i] * pi_i[k]) * 
                              (t_values[i] / pi_i[i]) * (t_values[k] / pi_i[k])
        }
      }
    }
    return(var_hat)
    
  } else if (method == "SYG" && !is.null(pi_ik)) {
    # Sen-Yates-Grundy variance estimator
    var_hat <- 0
    for (i in 1:n) {
      for (k in 1:n) {
        if (k != i) {
          var_hat <- var_hat + 0.5 * ((pi_ik[i, k] - pi_i[i] * pi_i[k]) / pi_ik[i, k]) * 
                              (t_values[i] / pi_i[i] - t_values[k] / pi_i[k])^2
        }
      }
    }
    return(var_hat)
    
  } else if (method == "WR") {
    # Simplified with-replacement variance estimator
    psi_i <- pi_i / n  # Approximate psi_i from pi_i
    var_hat <- (n / (n - 1)) * sum(((t_values / pi_i) - (t_hat_ht / n))^2)
    return(var_hat)
    
  } else {
    stop("Invalid method or missing joint inclusion probabilities")
  }
}

# Example usage
t_values <- c(100, 150, 200)  # Values for sampled units
pi_i <- c(0.3, 0.4, 0.5)     # Inclusion probabilities

# Create a simple example of joint inclusion probabilities (this is simplified)
pi_ik <- matrix(c(
  0.3, 0.1, 0.15,
  0.1, 0.4, 0.2,
  0.15, 0.2, 0.5
), nrow = 3, byrow = TRUE)

# Calculate variances using different methods
var_ht <- variance_one_stage_wor(t_values, pi_i, pi_ik, "HT")
var_syg <- variance_one_stage_wor(t_values, pi_i, pi_ik, "SYG")
var_wr <- variance_one_stage_wor(t_values, pi_i, method = "WR")

print(paste("HT variance estimate:", var_ht))
print(paste("SYG variance estimate:", var_syg))
print(paste("Simplified WR variance estimate:", var_wr))
```

6. Two-stage Sampling without Replacement

```{r}
# Function for two-stage sampling without replacement
two_stage_wor <- function(t_estimates, pi_i) {
  # t_estimates: estimated totals for sampled PSUs
  # pi_i: inclusion probabilities for PSUs
  
  # Calculate HT estimator
  t_hat_ht <- sum(t_estimates / pi_i)
  
  # Calculate simplified WR variance estimator
  n <- length(t_estimates)
  var_hat <- (n / (n - 1)) * sum(((t_estimates / pi_i) - (t_hat_ht / n))^2)
  
  return(list(
    t_hat_ht = t_hat_ht,
    variance = var_hat
  ))
}

# Example usage
t_estimates <- c(100, 150, 200)  # Estimated totals for sampled PSUs
pi_i <- c(0.3, 0.4, 0.5)        # Inclusion probabilities for PSUs

result <- two_stage_wor(t_estimates, pi_i)
print(paste("Estimated population total:", result$t_hat_ht))
print(paste("Variance estimate:", result$variance))
```

7. Weights and Mean Estimation in Unequal-probability Samples

```{r}
# Function for weights and mean estimation in unequal-probability samples
weighted_mean_estimator <- function(y_values, pi_i, pi_j_given_i) {
  # y_values: list of vectors containing y-values for each PSU
  # pi_i: inclusion probabilities for PSUs
  # pi_j_given_i: list of vectors containing conditional inclusion probs for SSUs
  
  # Calculate weights
  weights <- list()
  for (i in 1:length(pi_i)) {
    weights[[i]] <- 1 / (pi_j_given_i[[i]] * pi_i[i])
  }
  
  # Calculate weighted mean
  numerator <- 0
  denominator <- 0
  for (i in 1:length(pi_i)) {
    numerator <- numerator + sum(weights[[i]] * y_values[[i]])
    denominator <- denominator + sum(weights[[i]])
  }
  y_bar_ht <- numerator / denominator
  
  # Calculate M_i estimates (estimated number of SSUs in each PSU)
  M_hat <- numeric(length(pi_i))
  for (i in 1:length(pi_i)) {
    M_hat[i] <- sum(1 / pi_j_given_i[[i]])
  }
  
  # Calculate residuals for variance estimation
  e_hat <- numeric(length(pi_i))
  for (i in 1:length(pi_i)) {
    # t_i estimate
    t_i_hat <- sum(y_values[[i]] / pi_j_given_i[[i]])
    e_hat[i] <- t_i_hat - y_bar_ht * M_hat[i]
  }
  
  # Calculate variance using WR approximation
  n <- length(pi_i)
  
  # Alternative calculation using weights directly
  e_hat_alt <- numeric(length(pi_i))
  for (i in 1:length(pi_i)) {
    e_hat_alt[i] <- sum(weights[[i]] * (y_values[[i]] - y_bar_ht))
  }
  
  # Variance calculation
  e_squared_sum <- sum((e_hat_alt / denominator)^2)
  var_hat <- (n / (n - 1)) * e_squared_sum
  
  return(list(
    y_bar_ht = y_bar_ht,
    weights = weights,
    variance = var_hat
  ))
}

# Example usage
# Suppose we have 3 PSUs with different numbers of SSUs
y_values <- list(
  c(10, 15, 20),    # y-values for SSUs in PSU 1
  c(25, 30),        # y-values for SSUs in PSU 2
  c(35, 40, 45, 50) # y-values for SSUs in PSU 3
)
pi_i <- c(0.3, 0.4, 0.5)  # Inclusion probabilities for PSUs

# Conditional inclusion probabilities for SSUs given PSU is selected
pi_j_given_i <- list(
  c(0.6, 0.7, 0.8),      # For PSU 1
  c(0.5, 0.6),           # For PSU 2
  c(0.4, 0.5, 0.6, 0.7)  # For PSU 3
)

result <- weighted_mean_estimator(y_values, pi_i, pi_j_given_i)
print(paste("Estimated population mean:", result$y_bar_ht))
print(paste("Variance of the mean estimator:", result$variance))
print("Weights for each PSU's samples:")
print(result$weights)
```

## Class 8
## Sampling Probability Proportional to size

1. Basic PPS Sampling: Main Function
```{r}
# Function for PPS sampling with equal subsample sizes
basic_pps_sampling <- function(cluster_sizes, n_clusters, m_subsamples) {
  # Total population size
  M0 <- sum(cluster_sizes)
  
  # Calculate selection probabilities for clusters
  pps_probs <- cluster_sizes / M0
  
  # Select clusters with PPS
  selected_clusters <- sample(1:length(cluster_sizes), n_clusters, 
                              prob = pps_probs, replace = FALSE)
  
  # Calculate sampling fractions
  f_i <- (n_clusters * cluster_sizes[selected_clusters]) / M0
  f_j_given_i <- m_subsamples / cluster_sizes[selected_clusters]
  overall_f <- (n_clusters * m_subsamples) / M0
  
  return(list(
    selected_clusters = selected_clusters,
    pps_probabilities = pps_probs,
    first_stage_fraction = f_i,
    second_stage_fraction = f_j_given_i,
    overall_sampling_fraction = overall_f
  ))
}
```

2. Basic PPS Sampling: Usage Example
```{r}
# Example data
cluster_sizes <- c(120, 200, 130, 554, 300, 210, 190, 230, 226)
n_clusters <- 2
m_subsamples <- 18

# Run basic PPS sampling
set.seed(123)
result <- basic_pps_sampling(cluster_sizes, n_clusters, m_subsamples)

# Display results
print("Selected clusters:")
print(result$selected_clusters)
print("First-stage sampling fractions:")
print(result$first_stage_fraction)
print("Second-stage sampling fractions:")
print(result$second_stage_fraction)
print("Overall sampling fraction:")
print(result$overall_sampling_fraction)
```

3. Verifying EPSEM Property in PPS Sampling

```{r}
# Calculate and check overall sampling fraction for each selected cluster
overall_f_check <- result$first_stage_fraction * result$second_stage_fraction

# Compare with the target overall sampling fraction
print("Overall sampling fraction (target):")
print(result$overall_sampling_fraction)
print("Actual sampling fraction for selected clusters:")
print(overall_f_check)

# Check if design is EPSEM
is_epsem <- all(abs(overall_f_check - result$overall_sampling_fraction) < 1e-10)
print(paste("Is the design EPSEM?", is_epsem))
```


4. Systematic PPS Sampling: Main Function

```{r}
# Function for systematic PPS sampling
systematic_pps <- function(cluster_sizes, n_clusters, m_subsamples) {
  # Total population size
  M0 <- sum(cluster_sizes)
  
  # Calculate zone size (sampling interval)
  k <- M0 / n_clusters
  
  # Generate random start and selection points
  random_start <- runif(1, 1, k)
  selection_points <- random_start + (0:(n_clusters-1)) * k
  
  # Create cumulative sum and identify selected clusters
  cum_sizes <- cumsum(cluster_sizes)
  selected_clusters <- numeric(n_clusters)
  
  for (i in 1:n_clusters) {
    selected_clusters[i] <- which(cum_sizes >= selection_points[i])[1]
  }
  
  return(list(
    selected_clusters = selected_clusters,
    zone_size = k,
    random_start = random_start,
    selection_points = selection_points,
    cum_sizes = cum_sizes
  ))
}
```

5. Systematic PPS Sampling: Usage Example
```{r}
# Run systematic PPS sampling
set.seed(456)
result_sys <- systematic_pps(cluster_sizes, n_clusters, m_subsamples)

# Display results
print("Selection interval (zone size):")
print(result_sys$zone_size)
print("Random start:")
print(result_sys$random_start)
print("Selection points:")
print(result_sys$selection_points)
print("Selected clusters:")
print(result_sys$selected_clusters)
```

6. Calculating Sampling Fractions for Systematic PPS

```{r}
# Calculate first and second stage sampling fractions
f_i <- cluster_sizes[result_sys$selected_clusters] / result_sys$zone_size
f_j_given_i <- m_subsamples / cluster_sizes[result_sys$selected_clusters]
overall_f <- (n_clusters * m_subsamples) / sum(cluster_sizes)

# Check EPSEM property
overall_f_check <- f_i * f_j_given_i
is_epsem_sys <- all(abs(overall_f_check - overall_f) < 1e-10)

print("First-stage sampling fractions:")
print(f_i)
print("Second-stage sampling fractions:")
print(f_j_given_i)
print(paste("Is systematic PPS design EPSEM?", is_epsem_sys))
```


7. PPeS Sampling: Main Function

```{r}
# Function for PPeS sampling (Probability Proportional to estimated Size)
ppes_sampling_basic <- function(mos_values, n_clusters, target_m) {
  # Total estimated size
  mos_total <- sum(mos_values)
  
  # Selection interval
  interval <- mos_total / n_clusters
  
  # Random start and selection points
  random_start <- runif(1, 1, interval)
  selection_points <- random_start + (0:(n_clusters-1)) * interval
  
  # Cumulative MOS and selected clusters
  cum_mos <- cumsum(mos_values)
  selected_clusters <- numeric(n_clusters)
  
  for (i in 1:n_clusters) {
    selected_clusters[i] <- which(cum_mos >= selection_points[i])[1]
  }
  
  # Calculate subsampling rates
  subsampling_rates <- target_m / mos_values[selected_clusters]
  
  return(list(
    selected_clusters = selected_clusters,
    subsampling_rates = subsampling_rates
  ))
}
```

8. PPeS Sampling with Actual Sizes Different from MOS

```{r}
# Function to handle actual sizes vs. MOS
ppes_with_actual_sizes <- function(mos_values, actual_sizes, 
                                  selected_clusters, subsampling_rates) {
  # Expected subsample sizes based on actual sizes
  expected_subsample_sizes <- subsampling_rates * actual_sizes[selected_clusters]
  
  # Handle fractional sample sizes
  fractional_parts <- expected_subsample_sizes - floor(expected_subsample_sizes)
  final_sample_sizes <- floor(expected_subsample_sizes)
  
  # Randomized rounding
  set.seed(789)
  for (i in 1:length(fractional_parts)) {
    if (runif(1) < fractional_parts[i]) {
      final_sample_sizes[i] <- final_sample_sizes[i] + 1
    }
  }
  
  return(list(
    expected_sizes = expected_subsample_sizes,
    final_sizes = final_sample_sizes
  ))
}
```

9. PPeS Sampling: Usage Example
```{r}
# Example with MOS different from actual sizes
mos_values <- c(120, 200, 130, 554, 300, 210, 190, 230, 226)
actual_sizes <- c(125, 190, 135, 560, 295, 215, 185, 235, 230)
n_clusters <- 2
target_m <- 18

# Run PPeS sampling
set.seed(101)
ppes_result <- ppes_sampling_basic(mos_values, n_clusters, target_m)

# Handle difference between MOS and actual sizes
size_result <- ppes_with_actual_sizes(
  mos_values, actual_sizes,
  ppes_result$selected_clusters, 
  ppes_result$subsampling_rates
)

# Display results
print("Selected clusters:")
print(ppes_result$selected_clusters)
print("Expected subsample sizes:")
print(size_result$expected_sizes)
print("Final sample sizes after rounding:")
print(size_result$final_sizes)
```

10. Stratified PPS Sampling: Basic Setup

```{r}
# Function for stratified PPS: first stage
stratified_pps_setup <- function(cluster_sizes, strata) {
  # Identify unique strata
  unique_strata <- unique(strata)
  n_strata <- length(unique_strata)
  
  # Calculate stratum sizes
  stratum_sizes <- numeric(n_strata)
  for (h in 1:n_strata) {
    stratum_indices <- which(strata == unique_strata[h])
    stratum_sizes[h] <- sum(cluster_sizes[stratum_indices])
  }
  
  return(list(
    unique_strata = unique_strata,
    n_strata = n_strata,
    stratum_sizes = stratum_sizes
  ))
}
```

11. Stratified PPS Sampling: Within-Stratum Selection
```{r}
# Function for PPS selection within a stratum
within_stratum_pps <- function(stratum_sizes, n_clusters, m_subsamples) {
  # Total stratum size
  total_size <- sum(stratum_sizes)
  
  # Interval for systematic selection
  interval <- total_size / n_clusters
  random_start <- runif(1, 1, interval)
  selection_points <- random_start + (0:(n_clusters-1)) * interval
  
  # Cumulative sizes and selection
  cum_sizes <- cumsum(stratum_sizes)
  selected_indices <- numeric(n_clusters)
  
  for (i in 1:n_clusters) {
    selected_indices[i] <- which(cum_sizes >= selection_points[i])[1]
  }
  
  return(list(
    selected_indices = selected_indices,
    interval = interval
  ))
}
```

12. Stratified PPS Sampling: Complete Example
```{r}
# Example data for stratified sampling
cluster_sizes <- c(120, 200, 130, 554, 300, 210, 190, 230, 226)
strata <- c(1, 1, 1, 1, 1, 2, 2, 2, 2)  # 5 in stratum 1, 4 in stratum 2
n_clusters_per_strata <- c(2, 2)  # Select 2 from each stratum
m_subsamples <- 18

# Get stratum information
strat_info <- stratified_pps_setup(cluster_sizes, strata)

# Perform sampling in each stratum
selected_clusters <- list()
for (h in 1:strat_info$n_strata) {
  stratum <- strat_info$unique_strata[h]
  stratum_indices <- which(strata == stratum)
  stratum_cluster_sizes <- cluster_sizes[stratum_indices]
  
  # Select clusters within stratum
  result <- within_stratum_pps(stratum_cluster_sizes, n_clusters_per_strata[h], m_subsamples)
  
  # Map back to original indices
  selected_clusters[[h]] <- stratum_indices[result$selected_indices]
}

# Display results
for (h in 1:strat_info$n_strata) {
  cat("Stratum", h, "selected clusters:", selected_clusters[[h]], "\n")
}
```

13. Adjusting Subsample Sizes in Stratified PPeS
```{r}
# Function to calculate adjusted subsample sizes for stratified PPeS
adjust_subsample_sizes <- function(mos_values, strata, n_clusters_per_strata, target_f = 1/30) {
  # Identify unique strata
  unique_strata <- unique(strata)
  n_strata <- length(unique_strata)
  
  # Calculate MOS by stratum
  mos_by_stratum <- tapply(mos_values, strata, sum)
  
  # Calculate adjusted target subsample sizes
  m_star_by_stratum <- numeric(n_strata)
  for (h in 1:n_strata) {
    m_star_by_stratum[h] <- target_f * mos_by_stratum[h] / n_clusters_per_strata[h]
  }
  
  return(list(
    mos_by_stratum = mos_by_stratum,
    target_m_by_stratum = m_star_by_stratum
  ))
}
```

14. Implementing Fixed Sampling Fraction in Stratified PPeS
```{r}
# Example of adjusting subsample sizes to maintain equal sampling fraction
mos_values <- c(120, 200, 130, 554, 300, 210, 190, 230, 226)
strata <- c(1, 1, 1, 1, 1, 2, 2, 2, 2)
n_clusters_per_strata <- c(2, 2)
target_f <- 1/30  # Target overall sampling fraction

# Calculate adjusted subsample sizes
adj_result <- adjust_subsample_sizes(mos_values, strata, n_clusters_per_strata, target_f)

# Display results
cat("Stratum 1 MOS total:", adj_result$mos_by_stratum[1], "\n")
cat("Stratum 2 MOS total:", adj_result$mos_by_stratum[2], "\n")
cat("Adjusted target subsample size for stratum 1:", adj_result$target_m_by_stratum[1], "\n")
cat("Adjusted target subsample size for stratum 2:", adj_result$target_m_by_stratum[2], "\n")
```

15. Verifying EPSEM Property Across Strata
```{r}
# Calculate and verify overall sampling fractions by stratum
f1 <- n_clusters_per_strata[1] * adj_result$target_m_by_stratum[1] / adj_result$mos_by_stratum[1]
f2 <- n_clusters_per_strata[2] * adj_result$target_m_by_stratum[2] / adj_result$mos_by_stratum[2]

cat("Overall sampling fraction for stratum 1:", f1, "\n")
cat("Overall sampling fraction for stratum 2:", f2, "\n")
cat("Target sampling fraction:", target_f, "\n")
cat("Is the design EPSEM across strata?", abs(f1 - f2) < 1e-10, "\n")
```


## Class 7
## Systematic Sampling

1. Basic Systematic Sampling Function

```{r}
# Function to perform systematic sampling
systematic_sample <- function(population, n) {
  N <- length(population)
  
  # Calculate sampling interval
  k <- N / n
  
  # Generate random start between 1 and k
  random_start <- sample(1:ceiling(k), 1)
  
  # Generate indices for systematic sample
  indices <- seq(random_start, by = k, length.out = n)
  indices <- floor(indices)
  
  # Ensure indices are within bounds
  indices <- indices[indices <= N]
  
  # Return the sample
  return(list(
    sample = population[indices],
    indices = indices,
    interval = k,
    random_start = random_start
  ))
}

# Example usage
set.seed(123)
population <- 1:100
n <- 10
sys_sample <- systematic_sample(population, n)

print("Systematic sample:")
print(sys_sample$sample)
print(paste("Sampling interval (k):", sys_sample$interval))
print(paste("Random start:", sys_sample$random_start))
```

2. Theoretical Variance of Systematic Sampling
```{r}
# Function to calculate theoretical variance of systematic sampling
systematic_variance_theoretical <- function(population, M = 1) {
  # population: vector of population values
  # M: number of systematic samples (default: 1)
  
  N <- length(population)
  
  # Calculate population mean
  y_bar <- mean(population)
  
  # Calculate population variance S²
  S_squared <- sum((population - y_bar)^2) / (N - 1)
  
  # Calculate theoretical variance
  var_sys <- (1 - 1/M) * S_squared / N
  
  # For comparison, calculate SRS variance
  var_srs <- (1 - n/N) * S_squared / n
  
  return(list(
    systematic_variance = var_sys,
    srs_variance = var_srs,
    relative_efficiency = var_srs / var_sys
  ))
}

# Example usage
set.seed(123)
population <- rnorm(100, mean = 50, sd = 10)
result <- systematic_variance_theoretical(population)

print(paste("Theoretical systematic sampling variance:", result$systematic_variance))
print(paste("SRS variance for same sample size:", result$srs_variance))
print(paste("Relative efficiency (SRS/SYS):", result$relative_efficiency))
```

3. SRS Variance Estimation for Systematic Samples

```{r}
# Function to estimate variance using SRS formula
srs_variance_estimator <- function(sample, N) {
  # sample: systematic sample
  # N: population size
  
  n <- length(sample)
  
  # Calculate sample mean
  y_bar <- mean(sample)
  
  # Calculate sample variance
  s_squared <- sum((sample - y_bar)^2) / (n - 1)
  
  # Calculate finite population correction
  f <- n / N
  
  # Calculate estimated variance
  var_est <- (1 - f) * s_squared / n
  
  return(list(
    mean = y_bar,
    variance = var_est,
    standard_error = sqrt(var_est)
  ))
}

# Example usage
N <- 1000  # Population size
set.seed(123)
population <- rnorm(N, mean = 50, sd = 10)
n <- 100   # Sample size

# Generate systematic sample
sys_sample <- systematic_sample(population, n)

# Estimate variance using SRS formula
result <- srs_variance_estimator(sys_sample$sample, N)

print(paste("Estimated mean:", result$mean))
print(paste("Estimated variance using SRS formula:", result$variance))
print(paste("Estimated standard error:", result$standard_error))
```

4. Stratified Sampling Variance Estimation

```{r}
# Function to estimate variance using stratified sampling formula
stratified_variance_estimator <- function(samples, strata_weights, N) {
  # samples: list of samples from each stratum
  # strata_weights: vector of stratum weights (W_h)
  # N: total population size
  
  # Calculate total sample size
  n_total <- sum(sapply(samples, length))
  
  # Calculate overall sampling fraction
  f <- n_total / N
  
  # Calculate stratum variances
  stratum_vars <- numeric(length(samples))
  for (h in 1:length(samples)) {
    y_h <- samples[[h]]
    n_h <- length(y_h)
    stratum_vars[h] <- var(y_h)
  }
  
  # Calculate weighted sum of stratum variances
  weighted_var_sum <- sum(strata_weights * stratum_vars)
  
  # Calculate estimated variance
  var_est <- (1 - f) * weighted_var_sum / n_total
  
  return(var_est)
}

# Example usage
set.seed(123)
# Create strata in population
stratum1 <- rnorm(500, mean = 45, sd = 8)
stratum2 <- rnorm(300, mean = 55, sd = 12)
stratum3 <- rnorm(200, mean = 65, sd = 15)

# Take systematic samples from each stratum
sample1 <- systematic_sample(stratum1, 50)$sample
sample2 <- systematic_sample(stratum2, 30)$sample
sample3 <- systematic_sample(stratum3, 20)$sample

# Calculate stratum weights
N <- length(stratum1) + length(stratum2) + length(stratum3)
weights <- c(length(stratum1)/N, length(stratum2)/N, length(stratum3)/N)

# Estimate variance
samples <- list(sample1, sample2, sample3)
var_est <- stratified_variance_estimator(samples, weights, N)

print(paste("Estimated variance using stratified formula:", var_est))
print(paste("Estimated standard error:", sqrt(var_est)))
```

5. Paired Successive Rows Variance Estimation
```{r}
# Function to estimate variance by pairing successive rows
paired_rows_variance_estimator <- function(sample, N) {
  # sample: systematic sample
  # N: population size
  
  n <- length(sample)
  
  # Check if n is even
  if (n %% 2 != 0) {
    warning("Sample size is not even; dropping last observation")
    sample <- sample[1:(n-1)]
    n <- n - 1
  }
  
  # Pair successive rows
  pairs <- matrix(sample, ncol = 2, byrow = TRUE)
  
  # Calculate differences between pairs
  diffs_squared <- (pairs[, 1] - pairs[, 2])^2
  
  # Calculate sampling fraction
  f <- n / N
  
  # Calculate variance estimate
  var_est <- (1 - f) * sum(diffs_squared) / (n^2)
  
  return(list(
    variance = var_est,
    standard_error = sqrt(var_est)
  ))
}

# Example usage
set.seed(123)
population <- rnorm(1000, mean = 50, sd = 10)
n <- 100  # Must be even for pairing
N <- length(population)

# Generate systematic sample
sys_sample <- systematic_sample(population, n)

# Estimate variance using paired rows method
result <- paired_rows_variance_estimator(sys_sample$sample, N)

print(paste("Estimated variance using paired rows method:", result$variance))
print(paste("Estimated standard error:", result$standard_error))
```


6. Successive Differences Variance Estimation
```{r}
# Function to estimate variance using successive differences
successive_diff_variance_estimator <- function(sample, N) {
  # sample: systematic sample
  # N: population size
  
  n <- length(sample)
  
  # Calculate sampling fraction
  f <- n / N
  
  # Calculate successive differences
  diffs <- numeric(n - 1)
  for (i in 1:(n-1)) {
    diffs[i] <- (sample[i] - sample[i+1])^2
  }
  
  # Calculate variance estimate
  var_est <- (1 - f) * sum(diffs) / (2 * n * (n - 1))
  
  return(list(
    variance = var_est,
    standard_error = sqrt(var_est)
  ))
}

# Example usage
set.seed(123)
population <- rnorm(1000, mean = 50, sd = 10)
n <- 100
N <- length(population)

# Generate systematic sample
sys_sample <- systematic_sample(population, n)

# Estimate variance using successive differences method
result <- successive_diff_variance_estimator(sys_sample$sample, N)

print(paste("Estimated variance using successive differences:", result$variance))
print(paste("Estimated standard error:", result$standard_error))
```

7. Comparison of Variance Estimators
```{r}
# Function to compare different variance estimators
compare_variance_estimators <- function(population, n) {
  N <- length(population)
  
  # True population variance of mean
  pop_mean <- mean(population)
  pop_var <- var(population) * (1 - n/N) / n
  
  # Generate systematic sample
  sys_sample <- systematic_sample(population, n)$sample
  
  # 1. SRS variance estimator
  srs_result <- srs_variance_estimator(sys_sample, N)
  
  # 2. Paired rows variance estimator (if n is even)
  if (n %% 2 == 0) {
    paired_result <- paired_rows_variance_estimator(sys_sample, N)
  } else {
    paired_result <- list(variance = NA, standard_error = NA)
  }
  
  # 3. Successive differences variance estimator
  succ_result <- successive_diff_variance_estimator(sys_sample, N)
  
  # Calculate sample mean
  sample_mean <- mean(sys_sample)
  
  # Compare results
  results <- data.frame(
    Estimator = c("True Population Variance", "SRS Formula", 
                 "Paired Rows", "Successive Differences"),
    Variance = c(pop_var, srs_result$variance, 
                paired_result$variance, succ_result$variance),
    SE = c(sqrt(pop_var), srs_result$standard_error,
          paired_result$standard_error, succ_result$standard_error)
  )
  
  return(list(
    population_mean = pop_mean,
    sample_mean = sample_mean,
    results = results
  ))
}

# Example usage with a population with trend (where systematic sampling is more efficient)
set.seed(123)
N <- 1000
# Create population with trend
x <- 1:N
population <- 30 + 0.05 * x + rnorm(N, 0, 5)
n <- 100

comparison <- compare_variance_estimators(population, n)

print(paste("Population mean:", comparison$population_mean))
print(paste("Sample mean:", comparison$sample_mean))
print("Variance estimator comparison:")
print(comparison$results)
```

8. Circular Systematic Sampling
```{r}
# Function to perform circular systematic sampling
circular_systematic_sample <- function(population, n) {
  N <- length(population)
  
  # Calculate sampling interval
  k <- N / n
  
  # Generate random start between 1 and N
  random_start <- sample(1:N, 1)
  
  # Generate indices for circular systematic sample
  indices <- numeric(n)
  for (i in 1:n) {
    # Use modular arithmetic to wrap around
    index <- (random_start + (i-1)*k) %% N
    if (index == 0) index <- N  # Handle the case where index is exactly N
    indices[i] <- index
  }
  
  # Return the sample
  return(list(
    sample = population[indices],
    indices = indices,
    interval = k,
    random_start = random_start
  ))
}

# Example usage
set.seed(123)
population <- 1:100
n <- 10
circ_sample <- circular_systematic_sample(population, n)

print("Circular systematic sample:")
print(circ_sample$sample)
print(paste("Sampling interval (k):", circ_sample$interval))
print(paste("Random start:", circ_sample$random_start))
```

9. Systematic Sampling with Multiple Starts
```{r}
# Function to perform systematic sampling with multiple random starts
multiple_start_systematic_sample <- function(population, n, m) {
  # population: vector of population values
  # n: sample size for each systematic sample
  # m: number of random starts
  
  N <- length(population)
  
  # Calculate sampling interval
  k <- N / n
  
  # Generate m random starts between 1 and k
  random_starts <- sample(1:ceiling(k), m, replace = FALSE)
  
  # Generate m systematic samples
  samples <- list()
  for (j in 1:m) {
    start <- random_starts[j]
    indices <- seq(start, by = k, length.out = n)
    indices <- floor(indices)
    indices <- indices[indices <= N]
    
    samples[[j]] <- population[indices]
  }
  
  # Calculate combined sample mean
  combined_mean <- mean(unlist(samples))
  
  # Calculate between-sample variance
  sample_means <- sapply(samples, mean)
  between_var <- var(sample_means) / m
  
  return(list(
    samples = samples,
    random_starts = random_starts,
    sample_means = sample_means,
    combined_mean = combined_mean,
    between_sample_variance = between_var
  ))
}

# Example usage
set.seed(123)
population <- rnorm(1000, mean = 50, sd = 10)
n <- 20  # Sample size for each systematic sample
m <- 5   # Number of random starts

result <- multiple_start_systematic_sample(population, n, m)

print("Sample means from multiple systematic samples:")
print(result$sample_means)
print(paste("Combined mean:", result$combined_mean))
print(paste("Between-sample variance estimate:", result$between_sample_variance))
```

10. Systematic Sampling in Stratified Designs

```{r}
# Function to perform stratified systematic sampling
stratified_systematic_sample <- function(strata_populations, n_per_stratum) {
  # strata_populations: list of population vectors for each stratum
  # n_per_stratum: vector of sample sizes for each stratum
  
  n_strata <- length(strata_populations)
  
  # Check input dimensions
  if (length(n_per_stratum) != n_strata) {
    stop("Number of sample sizes must match number of strata")
  }
  
  # Perform systematic sampling in each stratum
  stratum_samples <- list()
  stratum_intervals <- numeric(n_strata)
  
  for (h in 1:n_strata) {
    pop_h <- strata_populations[[h]]
    n_h <- n_per_stratum[h]
    
    # Perform systematic sampling within stratum
    sample_h <- systematic_sample(pop_h, n_h)
    
    stratum_samples[[h]] <- sample_h$sample
    stratum_intervals[h] <- sample_h$interval
  }
  
  # Calculate stratum weights
  N_h <- sapply(strata_populations, length)
  N_total <- sum(N_h)
  stratum_weights <- N_h / N_total
  
  # Calculate overall mean
  stratum_means <- sapply(stratum_samples, mean)
  overall_mean <- sum(stratum_weights * stratum_means)
  
  return(list(
    stratum_samples = stratum_samples,
    stratum_means = stratum_means,
    stratum_weights = stratum_weights,
    stratum_intervals = stratum_intervals,
    overall_mean = overall_mean
  ))
}

# Example usage
set.seed(123)
# Create three strata populations
strata_pops <- list(
  rnorm(500, mean = 40, sd = 5),
  rnorm(300, mean = 60, sd = 8),
  rnorm(200, mean = 80, sd = 12)
)

# Sample sizes for each stratum
n_per_stratum <- c(50, 30, 20)

# Perform stratified systematic sampling
result <- stratified_systematic_sample(strata_pops, n_per_stratum)

print("Stratum means:")
print(result$stratum_means)
print("Stratum weights:")
print(result$stratum_weights)
print("Sampling intervals by stratum:")
print(result$stratum_intervals)
print(paste("Overall estimated mean:", result$overall_mean))
```


```{r}

```
```{r}

```


```{r}

```
```{r}

```


```{r}

```
```{r}

```


```{r}

```
```{r}

```


```{r}

```
```{r}

```


```{r}

```
```{r}

```
